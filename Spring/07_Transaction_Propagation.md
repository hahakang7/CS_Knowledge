# 트랜잭션 전파 (Transaction Propagation)

트랜잭션 전파는 하나의 트랜잭션이 실행 중일 때, 이 트랜잭션 안에서 호출되는 또 다른 메서드가 어떤 트랜잭션 상태에서 실행될지를 결정하는 방식이다. 주로 스프링 프레임워크(Spring Framework)의 `@Transactional` 어노테이션에서 사용된다.

예를 들어, 하나의 서비스 메서드에서 두 개의 다른 데이터베이스 테이블을 업데이트해야 한다고 가정해보자. 
트랜잭션 동기화가 없다면, 첫 번째 테이블 업데이트가 성공하고 두 번째 테이블 업데이트가 실패했을 때, 첫 번째 업데이트 결과가 그대로 남을 수 있다. 
하지만 트랜잭션 동기화를 사용하면 두 작업이 동일한 트랜잭션 안에서 수행되기 때문에 두 번째 업데이트가 실패하면 첫 번째 업데이트도 롤백되어 일관성이 유지된다.

## 물리 트랜잭션과 논리 트랜잭션

트랜잭션은 데이터베이스에서 제공하는 기술이므로 <u>커넥션 객체를 통해 처리한다. </u>그래서 <u>1개의 트랜잭션을 사용한다는 것은 하나의 커넥션 객체를 사용한다는 것</u>이고, 실제 데이터베이스의 트랜잭션을 사용한다는 점에서 물리 트랜잭션이라고도 한다. 물리 트랜잭션은 실제 커넥션에 롤백/커밋을 호출하는 것이므로 해당 트랜잭션이 끝나는 것이다.
앞서 설명하였듯 트랜잭션 전파 속성에 따라서 외부 트랜잭션과 내부 트랜잭션이 동일한 트랜잭션을 사용할 수도 있다. 하지만 스프링의 입장에서는 트랜잭션 매니저를 통해 트랜잭션을 처리하는 곳이 2군데이다. 그래서 실제 데이터베이스 트랜잭션과 스프링이 처리하는 트랜잭션 영역을 구분하기 위해 스프링은 논리 트랜잭션이라는 개념을 추가하였다. 예를 들어 다음의 그림은 외부 트랜잭션과 내부 트랜잭션이 1개의 물리 트랜잭션(커넥션)을 사용하는 경우이다.

<img src="./img/plTransaction.png">

이 경우에는 2개의 트랜잭션 범위가 존재하기 때문에 개별 논리 트랜잭션이 존재하지만, 실제로는 1개의 물리 트랜잭션이 사용된다. 만약 트랜잭션 전파 없이 1개의 트랜잭션만 사용되면 물리 트랜잭션만 존재하고, 트랜잭션 전파가 사용될 때 논리 트랜잭션 개념이 사용된다. 이러한 물리 트랜잭션과 논리 트랜잭션을 정리하면 다음과 같다.

- **물리 트랜잭션**: 실제 데이터베이스에 적용되는 트랜잭션으로, 커넥션을 통해 커밋/롤백하는 단위
- **논리 트랜잭션**: 스프링이 트랜잭션 매니저를 통해 트랜잭션을 처리하는 단위


기존의 트랜잭션이 진행중일 때 또 다른 트랜잭션이 사용되면 복잡한 상황이 발생한다. 스프링은 논리 트랜잭션이라는 개념을 도입함으로써 상황에 대한 설명을 쉽게 만들고, 다음과 같은 단순한 원칙을 세울수 있었다.

- 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋됨
- 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백됨

논리 트랜잭션을 기반으로 단순한 원칙을 세움으로써 2개 이상의 트랜잭션을 다루는 경우에 대한 이해가 상당히 쉬워진다. 실제로 트랜잭션들이 마주하는 상황에서 어떠한 전파 속성들이 있는지 살펴보도록 하자.


## 다양한 스프링의 트랜잭션 전파 속성

### REQUIRED 속성과 REQUIRES_NEW 속성

 스프링에는 7가지 전파 속성이 존재하는데, REQUIRED와 REQUIRES_NEW를 바탕으로 어떻게 진행되는지 살펴보도록 하자.  REQUIRED와 REQUIRES_NEW를 이해하면 나머지는 응용이 가능하므로, 두 케이스만 자세히 살펴보도록 하자.

#### REQUIRED

REQUIRED는 스프링이 제공하는 기본적인(DEFAULT) 전파 속성으로, 기본적으로 2개의 논리 트랜잭션을 묶어 1개의 물리 트랜잭션을 사용하는 것이다. 앞선 예시로 살펴본 경우가 REQUIRED에 해당하며, 내부 트랜잭션은 기존에 존재하는 외부 트랜잭션에 참여하게 된다.

<img src="./img/required.png">

여기서 참여한다는 것은 외부 트랜잭션을 그대로 이어간다는 뜻이며, 외부 트랜잭션의 범위가 내부까자 확장되는 것이다. 그러므로 내부 트랜잭션은 새로운 물리 트랜잭션을 사용하지 않는다.
하지만 트랜잭션 매니저에 의해 관리되는 논리 트랜잭션이 존재하므로 커밋은 내부 1회, 외부 1회해서 총 2회 실행된다. 물론 내부 트랜잭션은 논리 트랜잭션이기 때문에 커밋을 호출해도 즉시 커밋되지는 않고, 물리 트랜잭션을 관리하는 외부 트랜잭션이 최종적으로 커밋될 때 실제로 커밋이 된다. 롤백 역시 비슷한데, 내부 트랜잭션에서 롤백을 하여도 즉시 롤백되지 않는다. 물리 트랜잭션이 롤백될 때 실제 롤백이 처리되는데, 논리 트랜잭션들 중에서 1개라도 롤백되었다면 롤백된다.
하지만 외부 트랜잭션에서 롤백이 되는지 혹은 내부 트랜잭션에서 롤백이 되는지에 따라 동작 방식에 차이가 존재한다. 먼저 로직1에서 예외가 발생하여 외부 트랜잭션의 롤백이 필요한 경우에는 내부 트랜잭션의 커밋/롤백 여부와 무관하게 물리 트랜잭션에서 롤백을 시킨다. 마찬가지로  로직1은 커밋하고 로직2에서 예외가 발생하여 내부 트랜잭션에서 롤백되는 경우에도, 최종적으로 물리 트랜잭션에 롤백이 된다는 결과는 동일하다. 하지만 실제로 물리 트랜잭션을 관리하는 외부 트랜잭션에서는 커밋을 기대했지만 내부 트랜잭션이자 논리 트랜잭션에서 롤백을 필요로 하기 때문에, 외부 트랜잭션이자 물리 트랜잭션 입장에서는 예상치 못한 상황이라고 볼 수 있다. 따라서 내부 트랜잭션에서는  UnexpectedRollbackException 예외를 발생시켜 롤백 필요성을 알리고, 외부 트랜잭션에서는 이를 바탕으로 롤백을 처리한다.

#### REQUIRES_NEW

REQUIRES_NEW는 외부 트랜잭션과 내부 트랜잭션을 완전히 분리하는 전파 속성이다. 그래서 2개의 물리 트랜잭션이 사용되며, 각각 트랜잭션 별로 커밋과 롤백이 수행된다. 이를 그림을 표현하면 다음과 같다.

<img src="./img/requires_new.png">

두 개는 서로 다른 물리 트랜잭션이므로, 내부 트랜잭션 롤백이 외부 트랜잭션 롤백에 영향을 주지 않는다. 그러므로 내부 트랜잭션이 롤백 호출은 실제 커넥션에 롤백을 호출하는 것이므로 트랜잭션이 끝나게 된다.
서로 다른 물리 트랜잭션을 별도로 가진다는 것은 각각의 디비 커넥션이 사용된다는 것이다. 즉, 1개의 HTTP 요청에 대해 2개의 커넥션이 사용되는 것이다. 내부 트랜잭션이 처리 중일때는 꺼내진 외부 트랜잭션이 대기하는데, 이는 데이터베이스 커넥션을 고갈시킬 수 있다. 그러므로 조심해서 사용해야 하며, 만약 REQURES_NEW 없이 해결 가능하다면 대안책(별도의 클래스를 두기 등)을 사용하는 것이 좋다.

#### Propagation.REQUIRED

- 트랜잭션이 필요하고, 기존 트랜잭션이 있으면 사용하고 없으면 새로 만든다.
메서드가 호출될 때, 호출한 쪽에서 트랜잭션이 설정되어 있지 않다면 새로운 트랜잭션을 시작한다. (새로운 트랜잭션을 생성하여 실행)
- 이미 트랜잭션이 설정된 스코프에서 하위 메서드가 호출되면 상위 메서드의 트랜잭션 내에서 실행된다. (동일한 트랜잭션 내에서 실행)
- 하위 메서드에서 예외가 발생할 경우 해당 트랜잭션은 롤백되며, 이 롤백은 호출한 쪽에도 전파된다.

 
#### Propagation.REQUIRES_NEW

- 항상 새로운 트랜잭션이 필요하다.
- 메서드가 호출될 때, 항상 새로운 트랜잭션이 시작된다. (기존 트랜잭션이 있더라도 일시 중지하고, 새로운 트랜잭션을 생성하여 실행)
- 호출한 쪽에 트랜잭션이 설정되어 있더라도, 하위 메서드는 항상 독립적인 트랜잭션 내에서 실행된다. (기존 트랜잭션과 별개로 실행)
- 하위 메서드에서 예외가 발생할 경우, 해당 트랜잭션은 롤백되지만, 상위 트랜잭션에는 영향을 미치지 않는다. (상위 트랜잭션은 계속 진행)

 
#### Propagation.MANDATORY

- 트랜잭션이 의무이다.
- 메서드가 호출될 때, 반드시 트랜잭션이 설정되어 있어야 한다. (트랜잭션이 없는 경우 예외 발생)
- 호출한 쪽에서 트랜잭션이 설정되어 있다면, 그 트랜잭션 내에서 실행된다. (기존 트랜잭션 내에서 실행)
- 트랜잭션이 없는 상태에서 호출될 경우, IllegalTransactionStateException이 발생한다. (예외 발생)

 
#### Propagation.SUPPORTS

- 기존 트랜잭션이 있으면 사용하고 없으면 새로 만들지는 않고 없이 진행한다.
- 메서드가 호출될 때, 호출한 쪽에 트랜잭션이 설정되어 있다면 해당 트랜잭션 내에서 실행된다. (기존 트랜잭션 내에서 실행)
- 트랜잭션이 설정되지 않은 상태에서 메서드가 호출될 경우, 트랜잭션 없이 실행된다. (트랜잭션이 없어도 실행)
- 트랜잭션이 없는 상태에서 하위 메서드에서 예외가 발생하면, 트랜잭션과 관계없이 예외가 처리된다. (트랜잭션과 무관하게 예외 처리)

 
#### Propagation.NOT_SUPPORTED

- 트랜잭션을 지원하지 않고 기존에 트랜잭션이 있었어도 없이 진행한다.
- 메서드가 호출될 때, 호출한 쪽에 트랜잭션이 설정되어 있더라도 트랜잭션 없이 실행된다. (기존 트랜잭션이 일시 중지되고 실행)
- 트랜잭션이 설정된 상태에서 하위 메서드가 호출되면, 트랜잭션이 없는 상태로 실행된다. (트랜잭션을 중지하고 실행)
- 하위 메서드에서 예외가 발생해도 롤백이 전파되지 않으며, 트랜잭션과는 무관하게 예외가 처리된다. (트랜잭션과 독립적으로 예외 처리)

 
#### Propagation.NEVER

- 트랜잭션을 지원하지 않고 상위 스코프에도 트랜잭션이 설정되있으면 안 된다.
- 메서드가 호출될 때, 트랜잭션이 설정되어 있지 않아야 한다. (트랜잭션이 있는 경우 예외 발생)
- 호출한 쪽에 트랜잭션이 설정되어 있으면, IllegalTransactionStateException이 발생한다. (예외 발생)
- 트랜잭션이 없는 상태에서만 메서드가 정상적으로 실행되며, 트랜잭션 없이 실행된다. (트랜잭션 없는 상태로 실행)

 
#### Propagation.NESTED

- 중첩 트랜잭션 (자식 트랜잭션)을 만든다.
- 메서드가 호출될 때, 호출한 쪽에 트랜잭션이 설정되어 있다면 중첩 트랜잭션을 생성하여 실행된다. (상위 트랜잭션 내에 별도 저장점을 설정)
- 트랜잭션이 설정되지 않은 상태에서 호출될 경우, 새로운 트랜잭션이 시작된다. (새로운 트랜잭션 생성)
- 하위 메서드에서 예외가 발생할 경우, 중첩된 트랜잭션만 롤백되며, 상위 트랜잭션은 영향을 받지 않는다. (상위 트랜잭션은 롤백되지 않음)