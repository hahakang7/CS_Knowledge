# HTTP / HTTPS

- HTTP: 평문으로 데이터를 주고받는 프로토콜
- HTTPS: HTTP를 TLS(구 SSL) 위에 얹어서 주고받는 것

즉, 원래 HTTP가 하던 “요청/응답”은 그대로인데,
그 내용을 TLS가 암호화해서 감싸서 보내는 구조다.

- 기본 포트
  - HTTP: 80
  - HTTPS: 443

## HTTP와 HTTPS의 차이

먼저, HTTP에 대해서 알아보자.   
HTTP란 HyperText Transfer Protocol의 약자로써, 풀어서 설명하면 하이퍼텍스트(HyperText)를 전송(Transfer)하기 위해 사용되는 통신 규약(Protocol)이다. 즉, 인터넷에서 HTML과 같은 문서를 사용자 컴퓨터에 설치된 웹 브라우저가 웹 서버에 요청할 때의 규칙이라고 할 수 있다.  
HTTP 서버는 기본 포트인 80번 포트에서 서비스 대기 중이며, 클라이언트(웹 브라우저)가 TCP 80 포트를 사용해 연결하면 서버는 요청에 응답하면서 자료를 전송한다. HTTP는 정보를 텍스트로 주고 받기 때문에 네트워크에서 전송 신호를 인터셉트 하는 경우 원하지 않는 데이터 유출이 발생할 수 있다. 이러한 보안 취약점을 해결하기 위한 프로토콜이 HTTP에 S(Secure Socket Layer)가 추가된 HTTPS이다.

HTTPS는 기본 골격이나 사용 목적 등은 HTTP와 거의 동일하지만, 데이터를 주고 받는 과정에 '보안' 요소가 추가되었다는 것이 가장 큰 차이점이다. HTTPS를 사용하면 서버와 클라이언트 사이의 모든 통신 내용이 암호화된다.
우리가 특정 파일에 암호를 걸 때처럼 어떤 키를 설정해서 잠금을 걸고, 풀 때에도 그것을 입력해서 푸는 것을 생각해보자. 간단하게 생각하면 웹 서버가 키 하나를 정해 페이지를 암호화해서 사용자의 웹 브라우저로 보내고, 웹 브라우저는 그 키를 이용해서 페이지를 복원하면 될 것이다. 그러나 웹 서버는 하나고 사용자는 불특정 다수이기 때문에 간단하지 않다. 그렇다고 키를 사용자들에게 막 줘버리면 아무나 암호화를 풀 수 있게 됨으로써 암호화의 의미가 없게 된다.
HTTPS는 위와 같은 상황에서 페이지를 암호화한 키가 그 페이지를 보는 특정 사용자에게만 알려지도록 한다. HTTPS는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화하며, 기본 TCP/IP 포트는 443이고, SSL 프로토콜 위에서 HTTPS 프로토콜이 동작한다.

> [참고] TLS
Transport Layer Security의 줄임말. 과거 SSL에서 발전하며 이름이 변경 된 것이다. 하지만 아직도 SSL이란 명칭이 많이 사용되고 있다.

## TLS 1.2 ↔ TLS 1.3 차이

### TLS 1.2

- 왕복(RTT) 2회 필요
- RSA 키 교환 가능 **(Forward Secrecy 없음)**
- 여러 취약한 Cipher Suite 존재 (CBC, RC4 등)
- 핸드셰이크 메시지가 길고 복잡함

### TLS 1.3

- 왕복(RTT) 1회로 단축 → 더 빠름
- 모든 키 교환은 (EC)DHE만 허용 → **Forward Secrecy 보장**
- Cipher suite가 AEAD 방식으로 단순화 (AES-GCM, ChaCha20-Poly1305만)
- 과거 취약한 알고리즘(DSA, RSA key exchange, CBC) 전부 제거
- 0-RTT 모드 지원(재연결 시 요청을 더 빨리 보낼 수 있음)
- 단, 재전송 공격(resplay attack)에 취약 → 특정 경우만 사용

### Forward Secrecy

과거에 기록된 트래픽이 있어도, 서버의 비공개키가 유출되어도 과거 트래픽을 복호화할 수 없게 만드는 성질

#### 원리

RSA 방식(옛 방식)은 키 교환 과정이 다음 구조라 FS가 없다:

- 세션키를 RSA 공개키로 암호화 → 서버가 복호화
- 즉, 서버 비밀키가 털리면 과거 세션키도 복호화 가능

반면 ECDHE 방식(현대 방식)은:

- 키 교환에 “일회성 Ephemeral key” 를 사용
- 서버 개인키를 훔쳐도 과거 공유키는 계산할 수 없음
→ 그래서 TLS 1.3은 RSA 키 교환을 아예 제거함.

## HTTPS가 해결하는 3가지

HTTPS가 제공하는 건 딱 3개다:

- 기밀성(Confidentiality)
  - 중간에서 패킷을 가로채도 내용을 읽지 못하게 암호화
- 무결성(Integrity)
  - 데이터가 중간에서 바뀌었는지 검증(MAC / AEAD)
- 인증(Authentication)
  - “내가 진짜 naver.com 이냐?”를 인증서(Certificate) 를 통해 보장
  - 최소한 “서버 쪽”은 누구인지 확인 가능

## 암호화 방식

공개키 암호화 방식과 공개키의 느리다는 단점을 보완한 대칭키 암호화 방식을 함께 사용한다. 공개키 방식으로 대칭키를 전달하고, 서로 공유된 대칭키를 가지고 통신하게 된다.

### 공캐키 방식

- A키로 암호화를 하면 B키로 복호화를 할 수 있다
- B키로 암호화를 하면 A키로 복호화를 할 수 있다.
- 둘 중 하나를 비공개키(Private Key) 혹은 개인키라 부르며, 이는 자신만 가지고 있고 공개되지 않는다.
- 나머지 하나를 공개키(Public Key)라고 부르며 타인에게 제공한다. 공개키는 유출이 되어도 비공개키를 모르면 복호화 할 수 없기 때문에 안전하다.

### 대칭키 방식

- 동일한 키로 암호화, 복호화가 가능하다.
- 대칭키는 매번 랜덤으로 생성되어 누출되어도 다음에 사용할 때는 다른 키가 사용되기 때문에 안전하다.
- 공개키보다 빠르게 통신할 수 있다.

이러한 SSL 방식을 적용하려면 인증서를 발급받아 서버에 적용시켜야 한다. 인증서는 사용자가 접속한 서버가 우리가 의도한 서버가 맞는지를 보장하는 역할을 한다. 인증서를 발급하는 기관을 CA(Certificate Authority)라고 부른다. 공인인증기관의 경우 웹 브라우저는 미리 CA 리스트와 함께 각 CA의 공개키를 알고 있다.

> [참고] CA(Certificate Authority)란?
certification authority (CA)는 공개키와 공개 DNS명("www.example.com"같은)의 연결을 보장하는 기관이다. 예를 들어 클라이언트가 www.example.com의 공개키가 이 공개키인지 어떻게 알 수 있는가? 같은 것이다. 일단 이를 알 방법은 없다. CA는 자신만의 암호화 키로 웹사이트의 공개키를 암호학적으로 사인하는 데 사용함으로써 특정 공개키가 특정 사이트의 공개키라는 것을 보장한다. 이 서명은 계산적으로 위조할 가능성이 없다. 브라우저(그 외 클라이언트)는 잘 알려진 CS가 소유한 공개키를 보관하는 신뢰할 수 있는 anchor 저장소(trust anchor stores)를 유지하고 CS 서명을 암호학적으로 확인하는데 이 공개키를 사용한다.

### 왜 대칭키 + 비대칭키를 둘 다 쓰냐?

- TLS(HTTPS)는 대칭키 암호 + 비대칭키 암호를 섞는다.
  - 대칭키 암호(AES 등)
  - 같은 키로 암/복호화
  - 빠름 → 실제 데이터 전송에 사용
- 비대칭키 암호(RSA, ECDSA/ECDHE 등)
  - 공개키/개인키
  - 느림 → 키 교환/서명/인증에만 사용

구조: 
비대칭키로 “대칭키”를 안전하게 교환하고,
이후에는 그 대칭키로 데이터 전체를 빠르게 암호화한다.

## HTTPS(TLS) 핸드셰이크 흐름 (현대 TLS 1.2/1.3 기준, 단순화)

### 1단계: ClientHello

클라이언트(브라우저)가 서버에 **ClientHello** 메시지를 보낸다. 여기에 포함되는 정보:

- 클라이언트가 지원하는 **TLS 버전**
- 클라이언트가 지원하는 **암호 알고리즘 목록(ciphersuites)**
- 난수(`client_random`)
- **SNI(Server Name Indication)**: 접속하려는 호스트 이름 (예: `www.example.com`)
- 기타 확장 정보(ALPN, 압축 방식 등)

### 2단계: ServerHello (+ Certificate 등)

서버는 **ServerHello** 메시지로 응답하면서:

- 실제로 사용할 **TLS 버전** 선택
- 사용할 **암호 알고리즘(ciphersuite)** 선택
- 난수(`server_random`) 하나 더 생성
- **서버 인증서(Certificate)** 전송 (여기에 서버의 공개키가 들어 있음)
- (TLS 1.3 기준) 키 교환에 필요한 정보(ECDHE 등의 key share)도 같이 전송

### 3단계: 인증서 검증 (클라이언트가 수행)

클라이언트(브라우저)는 서버가 보낸 인증서를 보고 다음을 검증한다.

1. 인증서의 도메인 이름이 **내가 접속한 도메인과 일치하는지**
2. 인증서를 발급한 CA가 **신뢰할 수 있는 루트/중간 CA인지**
3. 인증서의 **유효 기간**(Not Before / Not After) 안에 있는지
4. 인증서가 **폐기(Revocation)** 되지 않았는지  
   - CRL, OCSP 등으로 확인

모두 통과하면:

> “이 서버는 진짜 내가 접속하려는 도메인이라고 믿을 수 있다”고 판단하고 다음 단계로 진행한다.

### 4단계: 키 교환 (대칭키 생성)

이제 본격적으로 **대칭키(세션 키)** 를 합의한다.  
현대 TLS(특히 1.2/1.3)는 보통 **(EC)DHE 기반 키 교환**을 사용한다.

- 클라이언트와 서버가 서로 키 교환 파라미터를 주고받고
- 수학적 연산을 통해 같은 **공유 비밀(shared secret)** 을 계산
- 이 공유 비밀로부터 **대칭키(세션 키)** 를 파생(키 스트레칭, KDF 등)

이 대칭키가 이후 **HTTP 데이터 암복호화에 사용되는 실제 키**다.

핵심 아이디어:

> **비대칭키(공개키/개인키)는 “대칭키를 안전하게 합의/교환”하는 데만 쓰고,  
> 실제 데이터 전송은 빠른 대칭키 암호(AES 등)로 처리한다.**

### 5단계: Finished / 암호화 전환

- 클라이언트와 서버는 서로 “Finished” 메시지를 교환하며  
  **지금까지의 핸드셰이크 과정이 중간에 변조되지 않았는지** 확인한다.
- 이후부터는 **모든 애플리케이션 데이터(HTTP 요청/응답)가  
  합의된 대칭키로 암호화되어 전송**된다.

즉, 이 시점 이후로는:

- 브라우저가 보내는 HTTP 요청 헤더/바디
- 서버가 보내는 HTTP 응답 헤더/바디

모두 TLS 레코드 프로토콜에 의해 암호화되어 전달된다.

### 한줄정리

> HTTPS 핸드셰이크는  
> 1) 서로 암호화 설정을 합의하고  
> 2) 인증서로 서버를 검증한 뒤  
> 3) 비대칭키 기반 키 교환으로 **대칭키(세션 키)** 를 만들고  
> 4) 그 대칭키로 이후 모든 HTTP 데이터를 암호화해서 주고받는 과정이다.

## HTTPS가 실제로 “뭘” 숨기고, “뭘” 못 숨기냐

숨기는 것(암호화됨)
- HTTP 요청/응답의:
  - URL의 path/쿼리 (/search?q=...)
  - 헤더(쿠키, Authorization 등 대부분)
  - 바디(폼 데이터, JSON, 비밀번호, 카드번호 등)

못 숨기는 것(평문으로 노출)
- 서버 IP
- 포트(443)
- 도메인(SNI는 평문인 경우 많음, ESNI/Encrypted Client Hello는 아직 보급 중)
- 패킷 크기/타이밍 패턴 (트래픽 분석 가능성)

## HTTP vs HTTPS 핵심 비교

| 항목     | HTTP         | HTTPS               |
| ------ | ------------ | ------------------- |
| 포트     | 80           | 443                 |
| 암호화    | 없음           | TLS(대칭 + 비대칭)       |
| 기밀성    | X            | O                   |
| 무결성    | X            | O (MAC/AEAD)        |
| 서버 인증  | X (별도 수단 필요) | O (인증서 기반)          |
| 중간자 공격 | 매우 쉬움        | 훨씬 어려움(인증서 위조 등 필요) |


