# 쿼리 최적화 (Query Optimization)

실제로 특정 데이터를 얻기 위한 요청을 처리할 때 해당 요청에 부합하는 쿼리는 여러가지가 있다. 이들 중, 최적의 query 찾아서 연산 시간을 줄이는 것을 query optimization 이라고 한다. 

동일한 결과를 내는 Relation, operation 조합들 중, 해당 상황에서 최적의 대안 쿼리를 찾아서 수행하는 것으로 이를 줄일 수 있다.

## DB는 SQL을 어떻게 “최적화”하나 

### 1. SQL을 내부 표현으로 바꾼다

- SQL → 파싱 → (대개) 관계대수(Selection/Projection/Join 등) 트리 같은 내부 표현으로 변환.

### 2. “논리적으로 같은 쿼리”로 바꾼다 (규칙 기반 변환)

결과는 같지만 성능이 좋아질 수 있는 변환들:
- 필터(WHERE)를 조인보다 먼저 적용해서 데이터 양을 줄이기 (push-down)
- 조인 순서 바꾸기 (결과는 같을 수 있음)

### 3. 여러 “물리 실행 계획”을 만들고 비용을 계산한다

예: 같은 조인이라도
- Nested Loop / Hash Join / Merge Join 중 뭘 쓸지
- Index Scan / Seq Scan 중 뭘 쓸지
- 정렬을 할지, 인덱스 순서를 이용할지
그리고 통계(카디널리티/선택도) 로 비용을 추정해 가장 싸다고 판단한 계획을 선택한다.

### 4. 실행(Execution)
선택된 계획대로 실제로 실행한다.


## “비용(cost)”은 뭘로 계산하나

옵티마이저는 이런 걸 근거로 “싸다/비싸다”를 판단한다.

- 얼마나 많은 행을 읽을지(selectivity, cardinality)
- 테이블/인덱스 페이지를 얼마나 읽을지(I/O)
- 정렬/해시/조인 연산을 얼마나 할지(CPU)

## 실전에서 최적화할 때 제일 자주 건드리는 것들 (원리만)

1. 인덱스가 “탐색”을 하게 만들기

- col = ?, col BETWEEN ? AND ?처럼 인덱스가 범위를 좁힐 수 있게.

2. 조인 전에 후보를 줄이기

- 필터를 먼저 먹여서 조인 입력 크기를 줄이면 비용이 급감.

3. 정렬/그룹 비용 줄이기

- 인덱스 순서로 ORDER BY를 대체하거나(가능할 때), 불필요한 sort를 피함.

4. 통계가 맞는지 확인

- 예상 행 수 vs 실제 행 수가 크게 어긋나면 계획이 망가질 확률이 큼.

