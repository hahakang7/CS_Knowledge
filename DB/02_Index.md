# Index (인덱스)

## 인덱스란?

테이블의 특정 컬럼에 대한 정렬된 데이터 구조로,
데이터를 빠르게 조회하기 위해 사용되는 검색용 자료구조이다.

- 책의 목차(index) 와 같은 개념
- “이 값이 어디에 있는지”를 빠르게 찾을 수 있게 포인터 저장.

만약 인덱스가 없다면 DB에서 데이터를 검색할 때 모든 레코드를 순차적으로 순회하면서 검색해야 할 것이다.  
하지만 인덱스가 있다면 이진 탐색(O(logN)) 으로 빠르게 위치를 찾고, 해당 데이터 주소(pointer) 로 바로 접근 가능. 대신 삽입, 수정, 삭제는 조금 느려진다.

### 인덱스의 장단점

#### 장점

- 검색 대상 레코드의 범위를 줄여 검색 속도를 빠르게 할 수 있다.
- 중복 데이터를 방지하거나 특정 컬럼의 유일성(Unique)을 보장할 수 있다.
- ORDER BY 절과 GROUP BY 절, WHERE 절 등이 사용되는 작업이 더욱 효율적으로 처리된다.

#### 단점

- 인덱스 생성에 따른 추가적인 저장 공간이 필요하다. (인덱스 사용 시 해당 정보를 담은 MYI 파일 생성)
- CREATE(삽입), DELETE(삭제), UPDATE(수정) 작업 시에도 인덱스를 업데이트해야 하므로 성능 저하가 발생할 수 있다.
- 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다.
- 인덱스 생성 시간이 오래 걸릴 수 있다.

인덱스는 데이터베이스에서 검색 및 처리하는 속도를 향상시키는 데 중요한 역할을 한다. 하지만, 인덱스를 적절하게 활용하지 않으면 오히려 데이터베이스의 성능이 저하되거나 저장 공간이 낭비될 수 있다.
따라서, 인덱스를 적절히 선택하고 생성하는 것이 중요하다.

## 인덱스의 자료구조

### B-Tree 인덱스 (가장 일반적)

Balanced Tree 구조 — 대부분의 RDBMS (MySQL, PostgreSQL 등)에서 사용

B-Tree는 데이터베이스에서 가장 널리 사용되는 인덱스 자료구조 중 하나이다. O(logN)의 시간 복잡도를 가지고 있다. B-Tree는 균형 잡힌 이진 검색 트리로 데이터베이스에서 검색 속도를 높이기 위해 사용된다.

B-Tree의 각 노드 내 데이터들은 항상 정렬된 상태인 것이 특징이며, 데이터와 데이터 사이의 범위를 이용하여 자식 노드를 가진다. (자식 노드의 개수는 n+1개)
또한, 한 노드에서 여러 개의 키를 가질 수 있고, 키에 해당하는 데이터도 함께 갖고 있다.

- 데이터가 정렬된 상태로 저장
- 모든 리프 노드(leaf)가 같은 깊이
- 검색 시 트리의 높이만큼 비교 → O(logN)
- 범위 검색(BETWEEN, LIKE 'abc%') 가능

**예시**

```
         [M]
       /     \
   [C,G]     [P,T]
```


### B+Tree
B+Tree는 B-Tree의 변형된 구조로 B-Tree와 비슷하지만 몇 가지 차이점을 가지고 있다. B+Tree 또한 균형 잡힌 이진 검색 트리이다. B+Tree는 B-Tree에 비해 더 많은 키를 가질 수 있다.

B+Tree는 B-Tree와 달리 내부 노드(Internal node)와 단말 노드(Leaf node)로 구분된다. B+Tree의 모든 데이터는 단말 노드에서만 저장되며, 내부 노드에는 검색을 위한 인덱스만 저장된다.

모든 리프 노드가 연결 리스트로 연결되어 있으며, 순차적으로 저장되어 있다. 이러한 특징으로 인해 범위 검색(Range Search)이나 순차 검색(Sequential Search)에 효율적이다.

### Hash 테이블

- 해시 함수로 키를 변환 → 해시 버킷에 저장
- 정확히 일치하는 검색에 매우 빠름 (O(1))
- 하지만 범위 검색 불가능
- InnoDB에서는 메모리 해시 인덱스(Adaptive Hash) 형태로 사용

### 자료구조 비교

| 구분                      | **B-Tree**       | **B+ Tree**                | **Hash**              |
| ----------------------- | ---------------- | -------------------------- | --------------------- |
| **검색 속도**               | O(logN)          | O(logN)                    | O(1)                  |
| **범위 검색**               | 가능               | **매우 효율적 (전용 구조)**         | 불가능                   |
| **정렬 지원**               | 가능               | 가능 (Leaf가 연결 리스트 구조)       | 불가능                   |
| **데이터 저장 위치**           | 모든 노드에 데이터 저장 가능 | **Leaf 노드에만 데이터 저장**       | 해시 버킷에 값 저장           |
| **Leaf 간 연결**           | 없음               | **연결 리스트로 모두 연결됨**         | 없음                    |
| **디스크 접근 효율**           | 보통               | **더 적음 (Leaf 단일 스캔으로 충분)** | 매우 빠름 (메모리 기반)        |
| **메모리 사용량**             | 보통               | 약간 많음                      | 많음                    |
| **적합한 검색**              | 등호/범위            | **범위, 순차 읽기 최적**           | 정확한 일치값      |

## 인덱스의 종류

| 구분                      | 설명                  | 예시                      |
| ----------------------- | ------------------- | ----------------------- |
| **Primary Index**       | 기본키(PK)에 자동 생성      | `PRIMARY KEY(id)`       |
| **Unique Index**        | 중복 없는 인덱스           | `UNIQUE(email)`         |
| **Composite Index**     | 여러 컬럼을 묶은 인덱스       | `(user_id, created_at)` |
| **Clustered Index**     | 실제 데이터가 인덱스 순서대로 저장 | InnoDB의 PK              |
| **Non-clustered Index** | 인덱스와 실제 데이터가 분리     | Secondary Index         |

## 인덱스를 생성할 때 주의해야 할 점

### “선택도(Selectivity)”가 높을수록 인덱스 효율 ↑

전체 데이터 중에서 조건을 만족하는 비율이 낮을수록 효율적
예: 성별(남/여)은 선택도 낮음 → 인덱스 비효율
이메일, 회원번호 등은 선택도 높음 → 인덱스 효율적
