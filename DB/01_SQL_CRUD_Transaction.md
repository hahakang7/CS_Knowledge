# SQL과 CRUD

### SQL이란?

SQL(Structured Query Language) 은 관계형 데이터베이스(RDBMS)[^1] 에서 데이터를 조회·추가·수정·삭제하기 위한 언어다.

### CRUD란?

CRUD는 데이터베이스의 기본 조작 4가지를 나타내는 약자이다.

| 글자    | 의미     | 동작     | SQL 명령   |
| ----- | ------ | ------ | -------- |
| **C** | Create | 데이터 생성 | `INSERT` |
| **R** | Read   | 데이터 조회 | `SELECT` |
| **U** | Update | 데이터 수정 | `UPDATE` |
| **D** | Delete | 데이터 삭제 | `DELETE` |

### SQL CRUD 예시

예시로 users 테이블이 있다고 하자

``` SQL
CREATE TABLE users (
  id INT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100),
  email VARCHAR(100),
  age INT
);

```

#### Create (생성)

새로운 데이터를 DB에 삽입하는 작업

``` SQL
INSERT INTO users (name, email, age)
VALUES ('홍길동', 'hong@example.com', 25);
```

**결과**

| id | name | email                                       | age |
| -- | ---- | ------------------------------------------- | --- |
| 1  | 홍길동  | [hong@example.com](mailto:hong@example.com) | 25  |

- INSERT INTO 테이블명
  - 데이터를 추가할 테이블명을 선택한다.
- (컬럼명)
  - 데이터를 입력할 컬럼명을 선택한다.
  - 컬럼명은 테이블의 컬럼 개수와 입력하는 데이터의 개수가 같을 경우 생략해도 된다.
  - 또한, 기본값이 있거나 널(NULL)값을 저장할 수 있는 컬럼 혹은 숫자가 자동 증가하는 컬럼일 경우도 생략 가능하다.
- VALUES (데이터값)
  - 추가할 데이터를 순차적으로 나열한다.
  - 앞에서 나열한 컬럼명의 개수와 동일하게 데이터의 값을 나열하여야 한다.

#### Read (조회)

저장된 데이터를 읽거나 검색하는 작업

``` SQL
-- 모든 데이터 조회
SELECT * FROM users;

-- 특정 조건으로 조회
SELECT * FROM users WHERE age >= 20;

-- 일부 컬럼만 조회
SELECT name, email FROM users WHERE id = 1;
```

- SELECT 컬럼명
  - 선택한 테이블에 존재하는 컬럼을 선택한다.
  - 컬럼 대신 별표(*)를 사용하면 테이블의 모든 컬럼을 선택할 수 있다.
- FROM 테이블명
  - 데이터를 조회할 테이블을 선택한다.
- WHERE 조건
  - 조회할 데이터의 조건이 존재한다면 조건을 추가한다.
  - 이 구문은 필수가 아니며 조건이 존재하지 않을 경우에는 생략해도 된다.

#### Update (수정)
기존 데이터를 변경하는 작업
WHERE 절을 써야 특정 행만 수정 가능!

``` SQL
UPDATE users
SET age = 26
WHERE id = 1;
```

- UPDATE 테이블명
  - 데이터를 갱신할 테이블을 선택한다.
- SET 컬럼명1 = 데이터값1
  - 선택한 컬럼에 기재한 데이터 값으로 데이터를 갱신한다.
  - WHERE 절의 조건이 없을 경우, 테이블의 모든 행이 갱신될 수 있으므로 주의하여야 한다.
- WHERE 조건
  - 갱신할 데이터의 조건이 존재한다면 조건을 추가한다.
  - 이 구문은 필수가 아니지만, 가급적 사용을 권장한다.

#### Delete (삭제)
데이터를 삭제하는 작업
WHERE 절을 빼면 모든 행이 삭제된다.

```SQL
DELETE FROM users
WHERE id = 1;
```

- DELETE FROM 테이블명
  - 데이터를 삭제할 테이블을 선택한다.
  - **주의** : 조건을 작성하지 않고 위의 쿼리만 실행할 경우 테이블의 모든 내용이 지워지니 조심해야 한다.
- WHERE 조건
  - 삭제할 데이터의 조건이 존재한다면 조건을 추가한다.
  - 이 구문은 필수가 아니지만 테이블의 모든 데이터가 삭제되기 때문에 가능한 필수적으로 사용을 권장한다.

##### CRUD는 DB 트랜잭션의 기본 단위

| 개념                  | 의미                        |
| ------------------- | ------------------------- |
| **A (Atomicity)**   | 모두 실행되거나 전혀 실행되지 않음 (원자성) |
| **C (Consistency)** | 제약조건 유지 (무결성)             |
| **I (Isolation)**   | 동시 실행 시 간섭 없음             |
| **D (Durability)**  | 성공한 트랜잭션은 영구 반영           |

이는 뒤에서 더 자세하게 다룰 예정이다.

#### CRUD 성능 관련 고려사항

| 항목                     | 설명                                      |
| ---------------------- | --------------------------------------- |
| **인덱스(Index)**         | `SELECT`, `UPDATE`, `DELETE` 시 검색 속도 향상 |
| **트랜잭션(Transaction)**  | 여러 CRUD를 하나로 묶어 원자성 보장                  |
| **락(Lock)**            | 동시 수정 충돌 방지                             |
| **정규화(Normalization)** | 데이터 중복 최소화로 효율적 CRUD 가능                 |
| **JOIN**               | 여러 테이블을 읽는 Read 성능 영향                   |

#### ORM (객체-관계 매핑)에서의 CRUD

Spring JPA, Hibernate, Django ORM, SQLAlchemy 같은 ORM[^2]에서도 CRUD는 거의 1:1 대응된다.

| CRUD   | JPA 메서드 예시                         |
| ------ | ---------------------------------- |
| Create | `save(entity)`                     |
| Read   | `findById(id)`, `findAll()`        |
| Update | `save(entity)` (변경감지로 자동 업데이트)     |
| Delete | `delete(entity)`, `deleteById(id)` |

# Transaction (트랜잭션)

### 트랜잭션이란?

트랜잭션은 “DB에서 수행되는 작업들을 하나의 묶음(단위)으로 보고, 그 묶음이 전부 성공하거나 전부 실패하도록 보장하는 메커니즘”이다.

각각의 트랜잭션은 상황에 따라 Commit(저장) 되거나 Rollback(철회) 될 수 있다.

- 커밋(Commit): 모든 부분작업이 정상적으로 완료하면 이 변경사항을 한꺼번에 DB에 반영한다.
- 롤백(Rollback): 부분 작업이 실패하면 트랜잭션 실행 전으로 되돌린다.

### 트랜잭션이 필요한 이유

예를 들면 “계좌 이체”를 생각해보자.

1. A 계좌에서 10만원 빼기
2. B 계좌에 10만원 넣기  
이 과정에서 DB가 다음과 같이 된다면?

- A 계좌에서 10만원은 빠졌는데
- B 계좌에는 돈이 들어가지 않음
→ 데이터 무결성 붕괴, 치명적인 오류
따라서 이 두 작업은 둘 다 성공하거나 둘 다 실패(롤백) 해야 한다.
이걸 보장하는 것이 트랜잭션이다.

### 트랜잭션 격리 수준

트랜잭션끼리 서로 어떻게 간섭을 차단할지를 결정한다.

| 격리 수준                | 설명                  | 문제                  |
| -------------------- | ------------------- | ------------------- |
| **READ UNCOMMITTED** | 커밋 안 된 데이터도 읽음      | Dirty Read          |
| **READ COMMITTED**   | 커밋된 데이터만 읽음         | Non-repeatable read |
| **REPEATABLE READ**  | 같은 SELECT는 항상 같은 결과 | Phantom read        |
| **SERIALIZABLE**     | 완전한 직렬 처리           | 성능 가장 낮음            |

일반적인 DB 기본 설정:

- MySQL: REPEATABLE READ
- PostgreSQL / Oracle: READ COMMITTED

### 트랜잭션의 내부 구현

DB는 트랜잭션을 다음을 이용해 구현한다:

| 메커니즘           | 설명                        |
| -------------- | ------------------------- |
| **Undo Log**   | 실패 시 데이터를 원래대로 되돌리기 위한 로그 |
| **Redo Log**   | 성공한 트랜잭션을 디스크에 반영하기 위한 로그 |
| **Locking(락)** | 동시성 제어                    |
| **MVCC**       | 스냅샷 기반 읽기, 동시성 성능 향상      |

예를 들어 MySQL InnoDB는
Undo/Redo 로그와 MVCC를 조합해 ACID를 보장한다.

## 트랜잭션이 보장해야 하는 4가지 — ACID 원칙

트랜잭션은 아래의 4가지 원칙을 반드시 지켜야 한다.

##### A — Atomicity (원자성)

**정의**
트랜잭션 안의 모든 작업이 전부 성공하거나 전부 실패하는 것. 즉, 일부만 반영되는것을 허용하지 않는다.

**구현 방식**

- 오류 발생 시 Undo Log 기반으로 이전 상태 복원

##### C — Consistency (일관성)

**정의**
트랜잭션 수행 전후로 데이터베이스의 규칙(무결성 제약)이 깨지지 않아야 한다.  
"규칙" = 무결성(Primary Key, Unique, Foreign Key), 체크 제약, 비즈니스 규칙 등

**핵심**
트랜잭션이 끝난 뒤 DB는 반드시 허용된 상태(valid state) 를 유지해야 한다.

##### I — Isolation (고립성)

**정의**
동시에 여러 트랜잭션이 실행되더라도 서로 간섭하지 않아야 한다

**Isolation Level에서 방지하는 대표 문제들**

| 이상 현상               | 설명                        |
| ------------------- | ------------------------- |
| Dirty Read          | 커밋 안 된 값 읽음               |
| Non-repeatable Read | 같은 SELECT를 두 번 하면 결과가 달라짐 |
| Phantom Read        | 조건을 만족하는 레코드 수가 바뀜        |

**구현 방식**

- Lock(Shared/Exclusive)
- [MVCC](#추가mvcc다중-버전-동시성-제어란)(버전 기반 읽기)

##### D — Durability (지속성)

**정의**
트랜잭션이 커밋된 내용은 DB가 장애가 나도 절대로 사라져서는 안 된다.

**구현 방식**

- Redo Log
- WAL(Write-Ahead Logging)
- Commit 시 Redo Log를 반드시 디스크에 기록
- 재부팅하면 Redo Log를 기반으로 재적용(redo)


### ACID 4가지 전체 요약 표

| 원칙                 | 의미                | 구현 기술                       |
| ------------------ | ----------------- | --------------------------- |
| **A(Atomicity)**   | 전부 성공 or 전부 실패    | Undo Log, Rollback          |
| **C(Consistency)** | 무결성 제약 항상 유지      | 제약 조건, 트리거, 엔진 로직           |
| **I(Isolation)**   | 트랜잭션끼리 간섭 차단      | Lock, MVCC, Isolation Level |
| **D(Durability)**  | Commit 후 절대 유실 없음 | Redo Log, WAL, 디스크 flush    |

# [추가]MVCC(다중 버전 동시성 제어)란?

## 동시성 제어(Concurrency Control)란?
동시성 제어란 DBMS가 다수의 사용자 사이에서 동시에 작용하는 다중 트랜잭션의 상호간섭 작용에서 Database를 보호하는 것을 의미한다.

다수 사용자의 동시 접속을 위해 DBMS는 동시성 제어를 할 수 있도록 Lock 기능과 SET TRANSACTION 명령어를 이용해 트랜잭션의 격리성 수준을 조정할 수 있는 기능도 제공한다. 이렇게 동시성을 제어하는 방법에는 낙관적 동시성 제어와 비관적 동시성 제어가 있다.

**낙관적 동시성 제어(Optimistic Concurrency Control)**
- 사용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정
- 데이터를 읽는 시점에 Lock을 걸지 않는 대신 수정 시점에 값이 변경됐는지를 반드시 검사

**비관적 동시성 제어(Pessimistic Concurrency Control)**
- 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정
- 데이터를 읽는 시점에 Lock을 걸고, 트랜잭션이 완료될 때까지 이를 유지
- SELECT 시점에 Lock을 거는 비관적 동시성 제어는 시스템의 동시성을 심각하게 떨어뜨릴 수 있어서 wait 또는 nowait 옵션과 함께 사용해야 함

동시성 제어의 목표는 동시에 실행되는 트랜잭션 수를 최대화 하면서 입력, 수정, 삭제, 검색 시 데이터의 무결성을 유지하는데 있다. 따라서 동시 업데이트가 거의 없는 경우라면 낙관적 잠금을 사용하면 되지만, 그렇지 않다면 비관적 제어를 사용해야 한다.

## [ 공유락(Shared Lock)과 배타락(Exclusive Lock) ]
비관적 동시성 제어를 위한 대표적인 방법으로 Lock이 있는데, 크게 공유락(Shared Lock)과 배타락(Exclusive Lock)이 있다.
- 공유락(Shared Lock): 읽기 잠금
- 배타락(Exclusive Lock): 쓰기 잠금

동일한 레코드에 대해 각각 공유락과 배타락을 가져간 경우의 동작은 다음과 같다.

1번 트랜잭션이 공유락을 가져간 경우

- 2번 트랜잭션이 데이터를 읽는 경우는 데이터가 일관되므로, 2번 트랜잭션이 또 다른 공유락을 가져가면서 동시에 처리함
- 2번 트랜잭션이 데이터를 쓰는 경우는 1번 트랜잭션과 데이터가 달라질 수 있므로 1번 트랜잭션 종료까지 기다려야 함

1번 트랜잭션이 배타락을 가져간 경우

- 2번 트랜잭션이 데이터를 읽는 경우, 1번 트랜잭션이 데이터를 변경할 수 있으므로 기다림
- 2번 트랜잭션이 데이터를 쓰는 경우에도, 1번 트랜잭션이 데이터를 변경할 수 있으므로 기다림

참고로 획득한 락을 해제하는 방법은 결국 커밋과 롤백 밖에 없다.
 이러한 방식의 일반적인 Locking 메커니즘은 구현이 간단한 반면에 아래와 같은 문제점을 가지고 있다.

##### Locking 메커니즘의 문제점

- 읽기 작업과 쓰기 작업이 서로 방해를 일으키기 때문에 동시성 문제가 발생
- 데이터 일관성에 문제가 생기는 경우도 있어서 Lock을 더 오래 유지하거나 테이블 레벨의 Lock을 사용해야 하고, 동시성 저하가 발생

이러한 문제점들을 해결하기 위해 MVCC라는(Multi-Version Concurrency Control, 다중 버전 동시성 제어)이 탄생하게 되었다.

## MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)

MVCC는 동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기 위해 사용하는 방법 중 하나이다.
MVCC는 원본의 데이터와 변경중인 데이터를 동시에 유지하는 방식으로, 원본 데이터에 대한 Snapshot을 백업하여 보관한다. 만약 두 가지 버전의 데이터가 존재하는 상황에서 새로운 사용자가 데이터에 접근하면 데이터베이스의 Snapshot을 읽는다. 그러다가 변경이 취소되면 원본 Snapshot을 바탕으로 데이터를 복구하고, 만약 변경이 완료되면 최종적으로 디스크에 반영하는 방식으로 동작한다.
결국 MVCC는 스냅샷을 이용하는 방식으로, 기존의 데이터를 덮어 씌우는게 아니라 기존의 데이터를 바탕으로 이전 버전의 데이터와 비교해서 변경된 내용을 기록한다. 이렇게 해서 하나의 데이터에 대해 여러 버전의 데이터가 존재하게 되고, 사용자는 마지막 버전의 데이터를 읽게 된다. 이러한 구조를 지닌 MVCC의 특징을 정리하면 아래와 같다.

- 일반적인 RDBMS보다 매우 빠르게 작동
- 사용하지 않는 데이터가 계속 쌓이게 되므로 데이터를 정리하는 시스템이 필요
- 데이터 버전이 충돌하면 애플리케이션 영역에서 이러한 문제를 해결해야 함

MVCC의 접근 방식은 잠금을 필요로 하지 않기 때문에 일반적인 RDBMS보다 매우 빠르게 작동한다. 또한 데이터를 읽기 시작할 때, 다른 사람이 그 데이터를 삭제하거나 수정하더라도 영향을 받지 않고 데이터를 사용할 수 있다. 대신 사용하지 않는 데이터가 계속 쌓이게 되므로 데이터를 정리하는 시스템이 필요하다. MVCC 모델은 하나의 데이터에 대한 여러 버전의 데이터를 허용하기 때문에 데이터 버전이 충돌될 수 있으므로 애플리케이션 영역에서 이러한 문제를 해결해야 한다. 또한 UNDO 블록 I/O, CR Copy 생성, CR 블록 캐싱 같은 부가적인 작업의 오버헤드 발생한다. 이러한 구조의 MVCC는 문장수준과 트랜잭션 수준의 읽기 일관성이 존재한다.

[^1]: 관계형 데이터베이스는 데이터를 행과 열로 이루어진 테이블 형태로 저장하고, 이러한 테이블들이 키(key)와 외래 키(foreign key)를 통해 서로 연결되어 관계를 맺는 데이터베이스입니다.
[^2]: ORM(Object-Relational Mapping)은 객체 지향 프로그래밍 언어의 객체와 관계형 데이터베이스의 테이블 간 데이터를 자동으로 연결하고 변환해주는 기술입니다. 이를 통해 개발자는 SQL 쿼리 대신 객체 지향적인 코드로 데이터베이스 작업을 수행할 수 있게 되어, 개발 과정이 단순해지고 생산성이 향상됩니다. 
