# 해시 인덱스 (Hash Index)

해시 테이블은 데이터 요소의 주소/인덱스 값이 해시 함수에서 생성되는 데이터 구조 유형이다. 인덱스 값이 데이터 값에 대한 키로 동작하므로 매우 빠른 데이터 액세스가 가능하다.

해시 테이블은 키-값 쌍을 저장하지만 키는 해싱 함수를 통해 생성된다. 따라서 키 값 자체가 데이터를 저장하는 배열의 인덱스가 되기 때문에 데이터 요소의 검색 및 삽입 기능이 훨씬 빨라진다. 조회하는 동안 키가 해시되고 결과 해시는 해당 값이 저장된 위치를 나타낸다.

<img width="600px" src="./img/hashimage.png">

## 해시 인덱스의 핵심 특징

### “등가 비교(=, IN)” 전용

해시 인덱스는 오직 다음과 같은 조건일 때만 빠르다:
- WHERE column = value
- WHERE column IN ( ... )

> 이유: 해시 함수는 key → 특정 버킷으로 바로 점프할 수 있으므로
“찾고 싶은 값이 정확히 뭔지 아는 경우”에 최적화됨.

### 정렬이 없다 (Range 검색 불가)
해시 인덱스는 정렬 구조가 아니다.
따라서 다음 조건들은 사용 불가:

- <, >, <=, >=, BETWEEN
- ORDER BY column
- prefix 검색 (LIKE 'abc%')

### 해시 충돌(hash collision) 존재

다른 key라도 해시값이 같으면 같은 버킷에 들어가야 함 → “체이닝(chaining)” 또는 “open addressing” 필요.

- 충돌 많아지면 성능 저하
- 하지만 올바른 해시 함수와 충분한 버킷 수로 제어 가능

#### 1. 체이닝(Chaining)

- 같은 인덱스에 여러 데이터를 연결 리스트로 저장하는 방법입니다.
- 충돌이 발생하면 해당 인덱스에 연결된 리스트에 데이터를 추가합니다.
- 간단하고 구현이 쉬우며, 확장성도 좋습니다.

#### 2. 오픈 어드레싱(Open Addressing)

- 충돌이 발생하면, 다른 빈 인덱스를 찾아 저장하는 방식입니다.
- 이때 빈 자리를 찾는 방식에 따라 여러 기법이 있습니다:
  - **선형 탐사(Linear Probing)**: 한 칸씩 이동하며 빈 공간을 찾음
  - **이차 탐사(Quadratic Probing)**: 제곱만큼 점프하며 빈 공간 탐색
  - **이중 해싱(Double Hashing)**: 두 개의 해시 함수를 이용해 다음 위치를 계산

# B+Tree 인덱스

B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. B+Tree는 모든 노드에 데이터(Value)를 저장했던 BTree와 다른 특성을 가지고 있다.

- 리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖는다.
- 리프노드들은 LinkedList로 연결되어 있다.
- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.

왜 +가 붙는가?
→ 데이터가 모두 리프 노드에만 존재하며, 리프 노드가 링크드 리스트로 연결되어 있기 때문.

<img width="700px" src="./img/BPtree.jpg">

구조 요약

- Root Node(루트): 시작점
- Internal Node(내부 노드): 분기 노드
- Leaf Node(리프 노드): 실제 레코드의 포인터를 저장하는 노드
- 리프 노드끼리는 Linked List로 연결되어 있음

## B+Tree 인덱스의 장점 / 단점

### 장점

| 장점                     | 이유                |
| ---------------------- | ----------------- |
| =, <, >, BETWEEN 모두 지원 | 정렬된 구조            |
| LIKE 'abc%' 가능         | prefix 검색 가능      |
| ORDER BY 최적화           | 인덱스 순서와 동일        |
| 트리 높이가 낮아 빠름           | 균형 트리 구조          |
| 디스크 접근 최소화             | 노드 구조가 페이지 크기와 맞음 |

### 단점

| 단점                     | 이유                                 |
| ---------------------- | ---------------------------------- |
| 삽입/삭제 비용이 비싸다          | split/merge로 트리 재조정 필요             |
| 랜덤 인서트가 많으면 비효율        | 정렬 구조 유지 때문에 비용 큼                  |
| 메모리 사용 증가              | 노드가 커서 인덱스 자체도 공간 차지               |
| 지나치게 많은 인덱스는 DML 성능 저하 | INSERT/UPDATE/DELETE마다 인덱스도 수정해야 함 |

## 복합 인덱스(B+Tree Multi-Column Index)의 정렬 규칙

예: 인덱스 (A, B, C)
정렬 우선순위: A → B → C

따라서 다음 조건은 가능:
- WHERE A = ?
- WHERE A = ? AND B = ?
- WHERE A = ? AND B BETWEEN ...
- ORDER BY A, B

반대로 다음은 불가능:
- WHERE B = ? 단독
- WHERE C = ? 단독

이유: 인덱스의 정렬 첫 기준은 항상 A이기 때문.