# Recursion (재귀)

## 재귀함수 (Recursion Function)

- 함수 내부에서 ‘자기 자신을 호출’하는 함수를 의미한다. 이를 통해서 함수가 자신을 반복적으로 호출하면서 원하는 결과를 도출할 수 있다.

- 단, 재귀함수를 사용하는 경우 함수 호출이 계속해서 쌓이기 때문에 호출 스택이 많아져서 성능이 저하될 수 있습니다. 따라서 재귀함수를 작성할 때는 무한루프에 빠지지 않도록 종료 조건을 명확하게 설정해주어야 합니다.

```
보조지식

호출 스택(Call Stack)이란?

- 프로그램에서 함수나 메서드를 호출할 때 해당 함수나  메서드의 실행이 끝날 때까지 실행되는 다른 함수나 메서드의 호출 정보를 저장하는 자료구조이다.
- 이 스택은 함수가 호출될 때마다 그 함수의 호출 정보를 저장하고 함수의 실행 결과가 반환되면 해당 함수의 호출 정보를 스택에서 제거한다.
- 호출 스텍은 디버깅, 예외 처리 및 재귀 함수와 같은 다양한 프로그래밍 작업에 사용된다.

재귀 함수와 재귀 알고리즘은 다른 것인가?

- 재귀 알고리즘은 문제를 해결하기 위해 재귀 함수를 사용하는 알고리즘을 의미한다
```

### 재귀함수의 장단점

**장점**

- 코드의 가독성이 높아진다. 
- 일부 알고리즘에서는 재귀를 사용하는 것이 더욱 직관적이다.

**단점**

- 재귀 함수는 함수를 호출할 때마다 스택에 새로운 프레임을 생성한다. 따라서, 스택이 너무 깊어질 경우에는 스택 오버플로우가 발생할 수 있다.
- 재귀 함수는 함수의 호출이 반복적으로 일어나기 때문에, 일반적으로 반복문을 사용하는 것보다 느리다.
- 

**재귀는 Call Stack 기반으로 동작함**

함수가 호출될 때마다:

- 지역 변수
- 매개변수
- 반환 주소

이 정보를 Call Stack(Frame) 에 저장하고
재귀 호출이 끝나야 스택에서 빠져나온다.



**Example)**

팩토리얼 계산 방법

``` java
public class Main {
    public static void main(String[] args) {
        System.out.println(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120
    }

    public static int factorial(int n) {
        if (n == 0) { // 기본 케이스
            return 1;
        } else { // 재귀 케이스
            return n * factorial(n - 1);
        }
    }
}
```

- 거듭제곱
- 문자열 뒤집기
- 유클리드 호제법 (최대공약수)
- 이진탐색

등등

