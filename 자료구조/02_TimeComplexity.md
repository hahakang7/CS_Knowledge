# 시간복잡도 (time complexity)

## 시간복잡도란?

시간복잡도(time complexity) 는 입력 크기 n 이 커질 때,
알고리즘이 얼마나 많은 연산을 수행하는지를 수학적으로 표현한 것.

## 시간복잡도 표현 방법

점근적 표기법(3가지)로 시간복잡도를 나타내는데 사용된다.

- 최상의 경우 : 오메가 표기법 (Big-Ω Notation)
- 평균의 경우 : 세타 표기법 (Big-θ Notation)
- 최악의 경우 : 빅오 표기법 (Big-O Notation)

평균인 세타 표기법을 사용한다고 생각할 수 도 있는데 평가하기 까다롭다는 판단이다. 

평균은 최상과 최악의 평균값으로  시간복잡도는 최악을 기준으로   "빅오 표기법" 으로 판단하여 성능을 예측한다. 

## Big-O 표기법(Big-O Notation)

Big-O는 “최악(worst case)” 기준으로
연산 증가량의 상한(upper bound)을 나타내는 표기법이다.

가장 많이 사용하는 시간복잡도는 아래 7개다:

| 시간복잡도          | 의미    | 예시            |
| -------------- | ----- | ------------- |
| **O(1)**       | 상수 시간 | 배열 인덱스 접근     |
| **O(log n)**   | 로그 시간 | 이진 탐색         |
| **O(n)**       | 선형 시간 | 순차 탐색         |
| **O(n log n)** | 로그 선형 | 병합 정렬, 퀵정렬 평균 |
| **O(n²)**      | 제곱 시간 | 이중 반복문        |
| **O(2ⁿ)**      | 지수 시간 | 부분집합 탐색, 백트래킹 |
| **O(n!)**      | 팩토리얼  | 순열 생성         |

### 각 시간복잡도 직관적으로 이해하기

#### O(1) — 상수 시간

입력 크기와 상관없이 “한 번만” 하는 연산.

```
arr[5];    // 배열 인덱스 접근
```

메모리 주소 계산만 하고 끝남 → 입력이 100이든 1억이든 동일.

#### O(log n) — 로그 시간

입력을 “절반씩 줄여가며” 처리하는 알고리즘.  

대표 예: 이진 탐색(Binary Search)  

n=1024일 때 비교 횟수:
→ log₂ 1024 = 10번만 비교하면 찾는다.

#### O(n) — 선형 시간

입력을 전부 한 번씩 스캔해야 하는 알고리즘.

````
for (i = 0; i < n; i++) { ... }
````

#### O(n log n) — 선형 로그

정렬 알고리즘 대부분이 이 시간복잡도를 가진다.
Ex)
- Merge Sort
- Quick Sort(평균)
- Heap Sort

이유(간단한 원리):
- 데이터를 log n 단계로 나눔
- 각 단계에서 n개의 데이터 처리
→ n × log n

#### O(n²) — 제곱 시간

중첩 반복문.
````
for(i=0; i<n; i++)  
  for(j=0; j<n; j++)
````
버블 정렬, 선택 정렬이 대표적.

#### O(2ⁿ) — 지수 시간

부분집합 전부 탐색하는 알고리즘.

Ex)
- 모든 부분집합 찾기
- 백트래킹 brute force

n = 20 -> 1,048,576
n = 30 -> 1,073,741,824 (약 10억)
→ 그래서 n=30만 되어도 현실적으로 못 돌린다.

#### O(n!) — 팩토리얼

순열을 전부 생성하는 알고리즘.

n=10이면 3,628,800개
→ 가장 비효율적인 종류

## 시간복잡도 계산 방법

가장 중요한 규칙 몇 가지:

Rule 1 — 가장 많이 반복되는 요소만 본다

```
for(i=0; i<n; i++) {
  print(i);
}
```

→ O(n)

안에 더하기/빼기/조건문 같은 O(1) 작업 100개 있어도
→ 여전히 O(n)

Rule 2 — 중첩 반복문은 곱한다

```
for i: n
  for j: n
```

→ O(n²)

Rule 3 — 여러 구간이 존재하면 가장 큰 것만 남긴다

```
for i: n     // O(n)
for j: n²    // O(n²)
```

전체 → O(n²)

Big-O는 증가율이 가장 큰 항만 남기는 상한(bound) 이기 때문.

Rule 4 — 재귀는 반복횟수로 풀어 쓴다

```
T(n) = 2T(n/2) + n
```

→ 병합 정렬의 전형적인 형태
→ 결과는 O(n log n)

## Tip

각 레벨마다 작업량을 보고 작업이 반복되면 레벨 깊이만큼 작업량에 곱하자
