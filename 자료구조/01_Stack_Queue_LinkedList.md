# 선형 자료구조

## 선형 자료구조란?

원소들이 일렬로(1차원 방향) 나열되어 있고,
각 원소가 이전/다음 원소와 논리적으로 연결된 구조를 말한다.

**특징**

- “앞→뒤”가 명확하다. (순서가 있다)
- 자료 간 관계가 1:1 관계 (각 원소는 보통 앞/뒤 하나씩만 가진다)
- 대표 예: 배열, 연결 리스트, 스택, 큐, 덱(Deque)

반대로 트리/그래프 같은 건 비선형 자료구조.

선형 자료구조는 보통 이렇게 나눌 수 있다.

1. 기본 선형 구조
   - 배열(Array)
   - 연결 리스트(Linked List)
2. 추상 자료형(ADT) 레벨에서의 선형 구조
   - 스택(Stack) – 한쪽 끝에서만 넣고 빼는 구조 (LIFO)
   - 큐(Queue) – 한쪽에서 넣고 반대쪽에서 빼는 구조 (FIFO)
   - 덱(Deque) – 양쪽 끝에서 넣고 빼는 구조

스택/큐/덱은 내부 구현으로 보통 배열이나 연결 리스트를 쓴다.

## 선형 자료구조의 종류

### 배열 (Array)

연속된 메모리 블록에 같은 타입의 원소를 순서대로 저장한 구조.

- 논리적 인덱스 i 가 실제 메모리 주소 base + i * element_size 에 바로 매핑됨
- 그래서 “랜덤 접근(random access)” 이 가능함

#### 장단점

##### 장점

- 인덱스 접근 빠름 (진짜 O(1))
- 연속 메모리 → CPU 캐시 효율 좋음 (성능에 꽤 영향 큼)

##### 단점

- 중간 삽입/삭제 비효율
- 크기 변경이 불편 (정적 배열)
- 동적 배열(ArrayList, vector)은 내부적으로 재할당·복사 비용 발생

### 연결 리스트 (Linked List)

각 원소를 노드(Node) 단위로 저장하고,
각 노드가 다음(그리고 경우에 따라 이전) 노드의 주소(포인터) 를 가지고 서로 연결된 구조.

#### 종류

- 단일 연결 리스트(Singly Linked List): data + next
- 이중 연결 리스트(Doubly Linked List): data + prev + next
- 원형 리스트(Circular): 마지막 노드가 다시 첫 노드를 가리킴

#### 노드 구조 예

``` text
[ data | next ] -> [ data | next ] -> [ data | next ] -> NULL
```

이중 연결 리스트는

``` text
NULL <- [ prev | data | next ] <-> [ prev | data | next ] <-> NULL
```

#### 핵심 연산 & 시간복잡도

| 연산        | 단일 연결 리스트                            | 설명                 |
| --------- | ------------------------------------ | ------------------ |
| 특정 위치 접근  | O(N)                                 | 앞에서부터 next 타고 가야 함 |
| 맨 앞 삽입/삭제 | O(1)                                 | head 포인터만 바꾸면 됨    |
| 맨 뒤 삽입    | O(N) (tail 없을 때) / O(1) (tail 있을 때)  |                    |
| 중간 삽입/삭제  | **노드 포인터 알고 있으면 O(1)**, 위치 찾는 데 O(N) |                  |  

#### 장단점

##### 장점

- 중간 삽입/삭제가 싸다(배열처럼 밀 필요 없음)
- 크기 제한 거의 없음 (메모리만 허용하면 됨)

##### 단점

- 임의 접근 불가 (인덱스로 O(1) 접근 X)
- 포인터 저장 오버헤드
- 메모리 여기저기 흩어져 있어 캐시 비효율

### 스택 (Stack) – LIFO

Last In First Out (나중에 들어온 게 먼저 나감) 구조.
한쪽 끝(Top)에서만 삽입/삭제가 일어나는 선형 구조.

**연산**  

- push(x) – top에 원소 추가
- pop() – top에서 원소 제거 및 반환
- peek()/top() – top의 원소 확인

#### 구현

- 배열 기반 스택
  - 배열 + top 인덱스
- 연결 리스트 기반 스택
  - head 쪽에 push/pop

### 큐 (Queue) – FIFO

First In First Out (먼저 들어온 게 먼저 나감) 구조.
한쪽(Rear)에서 넣고, 반대쪽(Front)에서 뺀다.

**연산**

- enqueue(x) – 뒤(rear)에 넣기
- dequeue() – 앞(front)에서 빼기
- front() – 맨 앞 원소 보기

#### 구현

- 배열 + 원형 인덱스(Circular Queue)
  - front, rear 인덱스가 있고,
  - 배열 끝까지 갔으면 다시 0으로 돌아오는 방식
- 연결 리스트 기반 큐
  - head(앞), tail(뒤) 포인터 사용
  - 삽입: tail에 O(1), 삭제: head에서 O(1)

### 덱 (Deque, Double-Ended Queue)

Double-Ended Queue
양쪽 끝에서 삽입/삭제가 모두 가능한 큐.

**연산**

- push_front(x), push_back(x)
- pop_front(), pop_back()
- front(), back()

### 전체 비교

| 자료구조      | 인덱스 접근    | 머리 삽입/삭제     | 꼬리 삽입/삭제         | 중간 삽입/삭제                     |
| --------- | --------- | ------------ | ---------------- | ---------------------------- |
| 배열        | **O(1)**  | O(N)         | O(1) (동적 배열 평균)  | **O(N)**                     |
| 단일 연결 리스트 | O(N)      | **O(1)**     | O(1) (tail 있을 때) | 노드 위치 알고 있으면 O(1), 찾는 데 O(N) |
| 스택        | top만 접근   | top에서 O(1)   | -                | -                            |
| 큐         | front만 접근 | front에서 O(1) | rear에서 O(1)      | -                            |
| 덱         | 양 끝 O(1)  | front에서 O(1) | back에서 O(1)      | -                            |

