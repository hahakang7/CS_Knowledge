# Scheduling
### 스케줄링이란?
**스케줄링**은 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업이다.
CPU는 한 번의 하나의 작업만 처리 가능한데, 여러개의 작업이 존재할 경우 해당 작업들이 번갈아 가면서 수행되도록 만드는 것을 스케줄링이라고 한다.

>**스케줄링과 문맥전환의 관계**  
>- 스케줄링은 “누가 다음에 실행될지 결정”  
>- 문맥 전환은 “그 프로세스로 실제로 전환하는 행위”  

### 언제 스케줄 하는가  
1. 새로운 프로세스가 생성되었을 때
   - 부모 혹은 자식 어느것을 스케줄 해도 무방
2. 프로세스 종료 시
   - Ready상태의 다른 프로세스
3. 프로세스가 I/O, 세마포어 등으로 대기
   - 다른 프로세스 스케줄
4. I/O인터럽트가 발생(즉, 현재 프로세스 중단)
   - I/O를 기다리다 이제 막 ready상태가 된 프로세스
   - 원래(중단되었던)프로세스
   - 제 3의 프로세스  

### 스케줄러(Scheduler)의 종류
| 구분  | 시점  | 역할    | 호출 빈도 | 영역 |
| ---| ---| --- | --- | ---|
| **장기 스케줄러 (Long-term Scheduler)**   | 프로세스가 시스템에 들어올 때 | 어떤 프로세스를 메모리에 올릴지 결정 (Admission control) | 낮음  | 디스크 → 메모리|
| **중기 스케줄러 (Medium-term Scheduler)** | 메모리 부족 시         | 일부 프로세스를 swap out / in[^1]                   | 중간 | 메모리 ↔ 디스크 |
| **단기 스케줄러 (Short-term Scheduler)**  | CPU 할당 시점마다      | Ready Queue 중 누가 CPU를 가질지 결정             | 매우 빈번함 (ms 단위) | 메모리 → CPU |

[^1]: 가상메모리 체제에서 너무 많은 프로세스가 적재되면 일부 프로세스를 메모리에서 디스크로 내보내고(swap-out), 메모리의 여유가 생기면 다시 적재(swap-in) 
#
                 ┌──────────────────────────┐
                 │       디스크(보조기억장치) │
                 └─────────────┬────────────┘       
                               │
                (장기 스케줄러) ▼
                 ┌──────────────────────────┐           
                 │        메모리(Ready Queue) │
                 └─────────────┬────────────┘
                               │
                (단기 스케줄러) ▼
                 ┌──────────────────────────┐
                 │           CPU             │
                 └─────────────┬────────────┘
                               │
                (중기 스케줄러) ▼
                 ┌──────────────────────────┐
                 │  Swap 영역(디스크로 이동) │
                 └──────────────────────────┘



### 스케줄링 방식
구분|	설명|	예시
|---|---|---|
**비선점형(Non-preemptive)**|	프로세스가 CPU를 스스로 놓을 때까지 빼앗지 않음|	FCFS, SJF, Priority(비선점형)
**선점형(Preemptive)**|	OS가 강제로 CPU를 다른 프로세스에게 넘길 수 있음|RR, SRTF, Priority(선점형), Multilevel Queue	
### 스케줄링의 목표
| 목표                     | 설명                        |
| ---------------------- | ------------------------- |
| **CPU 이용률 향상**         | CPU가 놀지 않게 유지             |
| **처리량(Throughput) 증가** | 단위 시간당 더 많은 프로세스 완료       |
| **대기 시간 최소화**          | Ready Queue에서 기다리는 시간 줄이기 |
| **응답 시간 단축**           | 사용자에게 빠른 반응 제공            |
| **공정성(Fairness)**      | 모든 프로세스가 CPU를 고르게 얻도록     |

### 스케줄링이 일어나는 경우
- 다음 실행시킬 프로세스의 선정이 필요한 경우
- 스케줄링 대상
  - 준비 리스트에 들어있는 프로세스들에 한함  

스케줄링은 즉 문맥전환을 발생시켜 (준비 -> 실행) 혹은 (실행 -> 준비)로 상태전이를 일으킨다. 

효율성과 공정성을 중요하게 생각한다!!
## 주요 스케줄링 알고리즘
### FCFS (First Come First Served)
- 도착 순서대로 처리
- 비선점형
- 단순하지만 Convoy Effect(호위 효과) 발생 가능  
  → 긴 작업이 CPU를 오래 점유하면 뒤의 짧은 작업이 대기
### SJF (Shortest Job First)
- 실행 시간이 가장 짧은 프로세스 우선
- 평균 대기 시간 최소화 (이론상 최적)
- 단점: 다음 작업의 실행 시간을 예측하기 어려움
- 비선점형 / 선점형(SRTF) 모두 존재
### Priority Scheduling
- 우선순위(priority) 가 높은 프로세스부터 실행
- 낮은 우선순위가 계속 밀릴 수 있음 → 기아(Starvation) 발생
- 해결책: Aging (오래 기다리면 우선순위 점점 올려주기)
### RR (Round Robin)
- 타임 슬라이스(Time Quantum) 단위로 CPU를 순환 배분
- 선점형 (타임 슬라이스 만료 시 강제 교체)
- 응답 속도가 빠르고 인터랙티브 환경에 적합
- 만약 타임퀀텀의 크기가 매우 크면 FCFS와 동일해진다
- 단점: 잦은 문맥교환 비용으로 처리율이 감소할 수 있다.
### Multilevel Queue Scheduling(다단계 큐 스케줄링)
- 프로세스를 여러 큐로 나누어 관리 (우선순위별 큐)
- 예: Foreground(인터랙티브), Background(배치작업)
- 각 큐마다 다른 스케줄링 알고리즘 적용 가능(RR, FCFS등)
### Multilevel Feedback Queue(다단계 피드백 큐 스케줄링)
- 다단계 큐 + 동적인 프로세스 우선순위 변화 적용
- 큐 간 이동이 가능
- 짧은 작업은 높은 우선순위 큐에서 실행, CPU를 오래 쓰면 점점 아래 큐로 이동
- 현대 OS (예: Linux CFS, Windows) 기본 아이디어

# 다중처리기 스케줄링
### 다중처리기 스케줄링이란?
두 개 이상의 CPU(또는 코어) 가 있을 때, 각 CPU에 어떤 프로세스를 언제 배정할지 결정하는 메커니즘이다.  
즉, 단일 CPU에서는 “누가 CPU를 쓸까?”였다면 다중 CPU 환경에서는 “누가, 어떤 CPU를 쓸까?”까지 고려해야 한다.
### 다중처리기 스케줄링이 필요한 이유
| 문제                          | 설명                           |
| --------------------------- | ---------------------------- |
| **부하 불균형 (Load Imbalance)** | 어떤 CPU는 놀고, 어떤 CPU는 과부하      |
| **캐시 일관성(Cache Coherency)** | 동일한 데이터가 여러 코어 캐시에 서로 다르게 존재 |
| **동기화 비용**                  | 공유 메모리 접근 시 Lock 필요 (병목 가능)  |
| **프로세스 이동 비용**              | 프로세스가 다른 CPU로 옮겨가면 캐시 초기화 필요 |
### 다중처리기 시스템의 유형
| 유형                                   | 설명                                              |
| ------------------------------------ | ----------------------------------------------- |
| **SMP (Symmetric Multiprocessing)**  | 모든 CPU가 동일한 역할을 하며, OS가 각 CPU를 균등하게 관리 (가장 일반적) |
| **AMP (Asymmetric Multiprocessing)** | 한 CPU는 OS 제어, 나머지는 특정 작업만 수행 (임베디드 환경에서 주로 사용)  |
### 처리기 친화성(Processor Affinity)
처리기 친화성이란 SMP 시스템이 한 처리기에서 다른 처리기로의 이주를 피하고 대신 같은 처리기에서 프로세스를 실행시키려고 하는 현상이다.  
#### 처리기 친화성 현상이 발생하는 원인은 무엇인가?
프로세스가 특정 처리기에서 실행중일 때 처리기에 의해 가장 최근에 접근된 자료가 그 처리기의 캐시를 캐시 메로리에 채우게 된다. 그런데 프로세스가 다른 처리기로 이주된다면 현재 처리기의 캐시 메모리 내용은 삭제되고 이주해 가는 처리기의 캐시 메모리에 다시 채워져야 한다. 즉, 현재 처리기의 캐시 메모리를 삭제하고 이주하는 처리기의 캐시 메모리를 다시 채우는 작업은 비용이 많이 들기 때문에 처리기 친화성 현상이 발생하는 것이다.

#### 처리기 친화성의 종류
**약한 친화성(soft affinity)** : 운영체제가 동일한 처리기에서 프로세스를 실행시키려고 노력하는 정책을 가지고 있지만 보장하지는 않을 때, 이 경우 프로세스가 처리기 사이에서 이주하는 것이 가능함  
**강한 친화성(hard affinity)** : 시스템 호출을 통하여 프로세스는 다른 처리기로 이주하지 않겠다고 명시적으로 지정할 수 있음

물리적인 위치도 친화성에 영향을 끼칠수 있다.  
예를들어 해당 CPU와 메모리가 같은 보드에 배치되어있어 빠른접근 가능

### 부하 균등화 (Load Balancing)
부하 균등화란 SMP 시스템의 모든 처리기 사이에 부하가 고르게 배분되도록 시도하는 것을 의미한다. 단, 부하 균등화 기능은 각 처리기가 자기 자신만의 큐를 가지고 있는 시스템에서만 필요한 기능이다.  
부하 균등화에서는 3가지의 방식이 있다.
| 방식                 | 설명                              |
| ------------------ | ------------------------------- |
| **Push Migration** | 중앙 스케줄러가 주기적으로 과부하 CPU의 작업을 덜어줌 |
| **Pull Migration** | 놀고 있는 CPU가 스스로 다른 CPU의 작업을 가져옴  |
| **Hybrid**         | 두 방법을 병행 (Linux CFS 스케줄러)       |

## 멀티코어 프로세서(Multicore Processor)
멀티코어 : 하나의 프로세서 칩 내에 여러 처리기 코어 내장(SMP보다 빠르고 전력소모 적음)[^2]
멀티쓰레드 멀티코어를 이용하면 HW스레드를 각 코어에 할당한다. 한 쓰레드가 메모리멈춤(Memory Stall)[^3]이 발생하면 다른 스레드로 전환하여 작업 지속수행

[^2]: OS 입장에서는 SMP 시스템과 동일
[^3]: Cache miss등 여러 원인에 의해 프로세서가 메모리 접근시 데이터 가용시점까지 대기시간 발생