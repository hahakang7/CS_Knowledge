# 가상메모리

가상 메모리는 물리적인 메모리(RAM)의 한계를 극복하기 위해 운영체제가 제공하는 메모리 관리 기법입니다.
프로세스에게 연속된 독립적인 주소 공간을 제공하여 실제 메모리보다 더 큰 메모리처럼 보이게 합니다.

## 장점

| 필요 이유             | 설명                     |
| ----------------- | ---------------------- |
|  **메모리 부족 해결**  | 실제 RAM보다 많은 데이터를 처리 가능 |
|  **프로세스 간 격리**  | 각 프로세스는 독립된 주소 공간을 가짐  |
|  **효율적 메모리 사용** | 실제로 필요한 부분만 메모리에 적재    |
|  **보안성 향상**     | 다른 프로세스의 메모리 접근 차단 가능  |

## 기본 개념

1. 논리 주소(Logical Address)
- 프로세스가 사용하는 주소
- CPU가 직접 참조하는 주소

2. 물리 주소(Physical Address)
- 실제 메모리(RAM)의 주소

3. 주소 변환
- CPU가 생성한 논리 주소는 MMU(Memory Management Unit)를 통해 물리 주소로 변환됨

## 메모리 경영 기법의 분류 요소

||공간 크기|사상 단위|적재 단위|단점|
|---|---|---|---|---|
|분할방법|논리=물리|전체 프로그램|전체 프로그램|외부단편화 발생|
|페이징|논리=물리|페이지(세그먼트 기법은 가변크기)|전체 프로그램|사상테이블인 페이지 테이블 필요|
|가상 메모리|논리>물리|페이지|프로그램 일부 적재|장점: 오버레이 가능. 부분적재로 메모리 활용도 증대|

## 주요 기술

1. **페이징(Paging)**
- 가상 메모리 공간을 일정한 크기의 **페이지(Page)**로 나누고
- 물리 메모리도 동일한 크기의 **프레임(Frame)**으로 나눔
- 페이지 테이블을 통해 논리 주소 → 물리 주소 매핑

``예시: 4KB 단위로 나눠서 필요한 페이지만 메모리에 로딩``

2. **세그멘테이션(Segmentation)**
- 메모리를 코드, 데이터, 스택 등 논리적인 단위로 나눔
- 각 세그먼트는 길이가 가변적이며 독립적인 크기를 가짐

``예시: 코드 세그먼트는 읽기 전용, 스택 세그먼트는 읽기/쓰기 가능 등``

**스왑(Swap) 공간**

- RAM이 부족할 경우, 하드디스크의 일부 공간을 보조 기억장치로 활용
- 필요한 페이지를 디스크로 내보내고, 다시 필요할 때 불러옴
- 페이지 교체 알고리즘이 적용됨 (예: LRU, FIFO 등)

### 페이지 교체 알고리즘

| 알고리즘                      | 설명                             |
| ------------------------- | ------------------------------ |
| FIFO                      | 가장 오래된 페이지 교체                  |
| LRU (Least Recently Used) | 가장 오래 사용되지 않은 페이지 교체           |
| Optimal                   | 앞으로 가장 늦게 사용될 페이지를 교체 (이론상 최적) |
| LFU                       | 가장 적게 사용된 페이지 교체               |

## 장점 vs 단점

| 장점                | 단점                       |
| ----------------- | ------------------------ |
| RAM보다 큰 메모리 사용 가능 | 속도가 느릴 수 있음 (디스크 접근)     |
| 프로세스 간 메모리 보호     | 페이지 폴트(Page Fault) 발생 가능 |
| 주소 공간 분리로 보안 강화   | 구현 복잡성 증가                |

