# 가상메모리

가상 메모리는 물리적인 메모리(RAM)의 한계를 극복하기 위해 운영체제가 제공하는 메모리 관리 기법입니다.
프로세스에게 연속된 독립적인 주소 공간을 제공하여 실제 메모리보다 더 큰 메모리처럼 보이게 합니다.

## 장점

| 필요 이유             | 설명                     |
| ----------------- | ---------------------- |
|  **메모리 부족 해결**  | 실제 RAM보다 많은 데이터를 처리 가능 |
|  **프로세스 간 격리**  | 각 프로세스는 독립된 주소 공간을 가짐  |
|  **효율적 메모리 사용** | 실제로 필요한 부분만 메모리에 적재    |
|  **보안성 향상**     | 다른 프로세스의 메모리 접근 차단 가능  |

## 기본 개념

1. 논리 주소(Logical Address)
- 프로세스가 사용하는 주소
- CPU가 직접 참조하는 주소

2. 물리 주소(Physical Address)
- 실제 메모리(RAM)의 주소

3. 주소 변환
- CPU가 생성한 논리 주소는 MMU(Memory Management Unit)를 통해 물리 주소로 변환됨

## 메모리 경영 기법의 분류 요소

||공간 크기|사상 단위|적재 단위|단점|
|---|---|---|---|---|
|분할방법|논리=물리|전체 프로그램|전체 프로그램|외부단편화 발생|
|페이징|논리=물리|페이지(세그먼트 기법은 가변크기)|전체 프로그램|사상테이블인 페이지 테이블 필요|
|가상 메모리|논리>물리|페이지|프로그램 일부 적재|장점: 오버레이 가능. 부분적재로 메모리 활용도 증대|

## 주요 기술

1. **페이징(Paging)**
- 가상 메모리 공간을 일정한 크기의 **페이지(Page)**로 나누고
- 물리 메모리도 동일한 크기의 **프레임(Frame)**으로 나눔
- 페이지 테이블을 통해 논리 주소 → 물리 주소 매핑

``예시: 4KB 단위로 나눠서 필요한 페이지만 메모리에 로딩``

2. **세그멘테이션(Segmentation)**
- 메모리를 코드, 데이터, 스택 등 논리적인 단위로 나눔
- 각 세그먼트는 길이가 가변적이며 독립적인 크기를 가짐

``예시: 코드 세그먼트는 읽기 전용, 스택 세그먼트는 읽기/쓰기 가능 등``

**스왑(Swap) 공간**

- RAM이 부족할 경우, 하드디스크의 일부 공간을 보조 기억장치로 활용
- 필요한 페이지를 디스크로 내보내고, 다시 필요할 때 불러옴
- 페이지 교체 알고리즘이 적용됨 (예: LRU, FIFO 등)

### 페이지 교체 알고리즘

| 알고리즘                      | 설명                             |
| ------------------------- | ------------------------------ |
| FIFO                      | 가장 오래된 페이지 교체                  |
| LRU (Least Recently Used) | 가장 오래 사용되지 않은 페이지 교체           |
| Optimal                   | 앞으로 가장 늦게 사용될 페이지를 교체 (이론상 최적) |
| LFU                       | 가장 적게 사용된 페이지 교체               |

## 장점 vs 단점

| 장점                | 단점                       |
| ----------------- | ------------------------ |
| RAM보다 큰 메모리 사용 가능 | 속도가 느릴 수 있음 (디스크 접근)     |
| 프로세스 간 메모리 보호     | 페이지 폴트(Page Fault) 발생 가능 |
| 주소 공간 분리로 보안 강화   | 구현 복잡성 증가                |

# 페이징

페이징은 **가상 메모리(Virtual Memory)** 를 구현하는 방식 중 하나로, 프로세스의 메모리 공간을 고정 크기인 페이지 단위로 나누어 관리하는 방식이다.

페이징은 프로세스를 일정한 작은 크기로 나누는데, 프로세스뿐아니라 hole도 같은 크기로 나눈다. 이러한 작은 조각들의 크기를 맞춰서 메모리에 할당한다. 

<img width="700px" src="./img/paging.png">


위 그림과 같이 프로세스 P1은 5개의 페이지로 나눌 수 있다. 이를 메인 메모리 5곳에 나눠서 할당하였다. CPU는 논리 주소로 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고 이는 메모리로 가기전에 각 페이지의 실제 메모리 주소가 저장되어 있는 테이블에서 물리 주소로 변경되어야 한다.

프로세스를 나눈 조각을 **page** 라 하고, 메모리를 나눈 조각을 **frame** 이라 한다. 프로세스는 페이지의 집합이고, 메모리는 프레임의 집합이다. 프로세스를 정상적으로 사용하기 위해 MMU의 재배치 레지스터를 여러개 사용해서 위의 그림과 같이 각 페이지의 실제 주소로 변경해준다. 이러한 여러 개의 재배치 레지스터를 **페이지 테이블(Page Table)** 이라 한다.

연속 메모리 할당을 하면서 외부 단편화가 발생하여 이를 해결하기 위해 페이징 기법이 나왔다. 하지만 페이징은 외부 단편화가 아닌 **내부 단편화**[^2]가 발생한다.

[^2]: 내부단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 프레임을 다 채울 수 없다. 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어진다.
내부단편화는 해결할 방법이 없다. 하지만 내부단편화는 외부단편화에 비해 낭비되는 메모리 공간은 매우 적다. 내부단편화의 최대 낭비되는 크기는 page size - 1 이 된다.(외부 단편화는 최대 전체 메모리의 1/3이 낭비된다고 이전에 살펴봤다.) 이는 무시할 정도로 작은 크기이다.


## 페이징의 핵심 개념

### 가상 주소 vs 물리 주소

- 가상 주소(Virtual Address): 프로세스가 사용하는 주소
- 물리 주소(Physical Address): 실제 RAM의 주소
- 페이징은 **가상 주소를 물리 주소로 매핑(mapping)**하는 역할을 합니다.

### 페이지(Page)와 프레임(Frame)

**페이지(Page)**: 프로세스의 가상 메모리를 일정한 크기로 나눈 단위 (ex. 4KB)

**프레임(Frame)**: 실제 물리 메모리를 같은 크기로 나눈 단위

### 페이지 테이블(Page Table)

- 가상 페이지 번호를 물리 프레임 번호로 바꿔주는 주소 변환표
- 각 프로세스마다 독립된 페이지 테이블을 가짐
- 페이지 테이블 항목에는 다음과 같은 정보가 있음:
  - 프레임 번호
  - 존재 여부(Valid Bit)
  - 수정 여부(Dirty Bit)
  - 접근 권한(Read/Write 등)

## 주소 변환 과정

1. CPU는 가상 주소를 생성
2. 가상 주소는 **페이지 번호(Page Number)** 와 **오프셋(Offset)** 으로 나뉨
3. 페이지 테이블을 참조하여 페이지 번호에 대응하는 프레임 번호를 얻음
4. 물리 주소 = 프레임 번호 + 오프셋

## 페이징의 장점과 단점

### 장점

- 외부 단편화(External Fragmentation) 없음
- 가상 메모리 구현 가능 → 실제 메모리보다 큰 프로그램 실행 가능
- 프로세스 간 메모리 보호

### 단점

- 페이지 테이블이 커질 수 있음
- 주소 변환에 오버헤드 발생 → 성능 저하
- 캐시 미스가 늘어날 수 있음 (TLB 미스)

