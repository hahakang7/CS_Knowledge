# Deadlock (데드락)

데드락 = 여러 프로세스가 서로가 가진 자원을 기다리며 영원히 진행되지 못하는 상태.

핵심 조건은 “순환 대기(circular wait)”이며, 모든 프로세스가 서로를 기다려 어느 누구도 앞으로 실행될 수 없다.

## 데드락이 발생하려면 반드시 필요한 4가지 조건

**① 상호 배제(Mutual Exclusion)**
- 자원은 동시에 여러 프로세스가 공유할 수 없다 → 즉 “독점 자원”.
- 예: 프린터, 파일 lock, 세마포어 1개짜리

**② 점유 대기(Hold and Wait)**
- 프로세스가 일부 자원을 가진 상태에서 추가 자원을 요청하며 기다림.

**③ 비선점(No Preemption)**
- OS가 강제로 자원을 빼앗을 수 없다.
- 자원은 오직 그걸 가진 프로세스가 스스로 반납해야 한다.

**④ 순환 대기(Circular Wait)**
- 프로세스들이 원을 이루며 서로의 자원을 기다리는 구조가 되어야 한다.

- 예:
P1이 R1 보유 → R2 기다림
P2가 R2 보유 → R3 기다림
P3가 R3 보유 → R1 기다림
→ 원(circle) 발생 → 모두 교착

## 데드락이 실제로 왜 문제가 되는가

(step-by-step 내부 동작 분석)

1. OS는 lock 요청을 처리하려고 한다.
2. 하지만 어떤 프로세스가 lock A를 가진 채 lock B를 요청한다.
3. 동시에 다른 프로세스가 lock B를 가진 채 lock A를 요청한다.
4. 둘 다 상대방이 가진 lock이 반납되기만을 기다린다.
5. 그러나 상대방도 새로운 lock을 못 얻어 진행이 불가능 → 둘 다 멈춤.
6. OS는 강제로 lock을 뺏을 권한이 없으면(deadlock 조건 ③) 해결 못 함.
7. 그래서 데드락은 “정지된 상태 그대로 영원히 기다리게 되는 비정상 상태”가 된다.

## 데드락 해결 전략

### ① 데드락 예방(Prevention)

아예 Coffman 조건 중 하나를 강제로 깨버리는 방식이다.

예:
- 상호 배제 제거? → 불가능한 자원 많음
- 점유·대기 제거? → 자원을 요청하기 전에 모두 미리 획득하게 강제
- 비선점 제거? → 필요하면 OS가 자원을 강제로 빼앗음

- 순환 대기 제거? → “자원 순서를 강제”해서 cycle이 생기지 않도록 함
  - 예: 모든 lock에 번호를 붙이고 항상 번호가 큰 lock부터 요청하게 규칙화

단점: 시스템 효율이 떨어짐.

### 데드락 회피(Avoidance)

데드락이 “발생하기 전에” 시스템 상태가 안전한지 검사하며 자원 할당을 결정한다.

대표 알고리즘 → **Banker’s Algorithm(은행가 알고리즘)**[^1]

- 프로세스가 미래에 필요한 최대 자원량을 미리 선언해야 한다.
- 요청을 들어줬을 때 “안전 상태”가 유지되는지 체크 후 허용.

단점:
- 프로세스가 미래 자원 요구량을 정확히 알아야 함 → 현실에서 어려움.

[^1]: 어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전, 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시물레이션 해서 Safe State에 들 수 있는지 여부를 검사한다.
그러나, 은행원 알고리즘은 이처럼 미리 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원 수가 일정해야 하는 등 사용에 있어 제약조건이 많다는 단점도 존재한다.


### 데드락 탐지(Detection) + 회복(Recovery)

#### 탐지

- 주기적으로 자원 할당 그래프(Resource Allocation Graph)를 검사해 **cycle(순환)** 이 생겼는지 확인.

#### 회복 방식 3가지

1. 교착된 프로세스 중 하나를 강제 종료
2. 자원을 빼앗아 회복 (state rollback 필요)
3. checkpoint 지점으로 되돌리고 다시 실행

단점: 복구 비용이 큼.

### 데드락 무시(Ignore) → 실제 운영체제 대부분이 이 방식

일명 “鸚鵡 정책(오류를 무시하는 정책)” — 은근히 현실적.

리눅스, 윈도우, macOS 대부분은 “데드락 자동 해결” 기능이 없다.
그냥 개발자가 알아서 해결하도록 맡긴다.

이유:
- OS 레벨에서 탐지·회피·예방을 모두 하면 오버헤드가 너무 크다.
- 데드락은 대부분 어플리케이션 레벨에서 lock 설계가 잘못돼서 발생한다.

